// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//pressure
RWStructuredBuffer<float> smokeDensity;
RWStructuredBuffer<float> smokeDensityNew;

//temperature
RWStructuredBuffer<float> temperature;
RWStructuredBuffer<float> temperatureNew;

//smoke velocity
RWStructuredBuffer<float> velocityX;
RWStructuredBuffer<float> velocityY;
RWStructuredBuffer<float> velocityZ;

RWStructuredBuffer<float> velocityNewX;
RWStructuredBuffer<float> velocityNewY;
RWStructuredBuffer<float> velocityNewZ;

//intermediate velocity field
RWStructuredBuffer<float4> ccvelocity;

//smoke vorticity
RWStructuredBuffer<float4> vorticity;

//display property of smoke (radiance mean brigthness)
RWStructuredBuffer<float> smokeVoxelRadiance;
RWStructuredBuffer<float> smokeVoxelTransparency;

//domain size
int unitPerSide;
float tempAmbiant;
float pressureAtmos;


uint flatten(uint3 coord)
{
    return coord.x + unitPerSide * (coord.y + unitPerSide * coord.z);
}

uint flattenPlusOne(uint3 coord)
{
    return coord.x + (unitPerSide+1) * (coord.y + (unitPerSide+1) * coord.z);
}

[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    uint flat = flatten(id);
    uint flatPlusOne = flattenPlusOne(id);

    //init each buffer before the simulation
    
    //check if inbound
    if (flat < pow(unitPerSide, 3))
    {
        smokeDensity[flatten(id)] = max(10.0 - distance(id, uint3(unitPerSide / 2, 0, unitPerSide / 2)), pressureAtmos);
        temperature[flatten(id)] = tempAmbiant;
    }

    //another inbound cher
    if (flatPlusOne < pow((unitPerSide+1), 3))
    {
        velocityX[flattenPlusOne(id)] = 0.0;
        velocityY[flattenPlusOne(id)] = 0.0;
        velocityZ[flattenPlusOne(id)] = 0.0;

        vorticity[flattenPlusOne(id)] = float4(0.0, 0.0, 0.0, 1.0);
    }

}
