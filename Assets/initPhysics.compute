// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//pressure
RWStructuredBuffer<float> smokeDensity;

//temperature
RWStructuredBuffer<float> temperature;

//smoke velocity
RWStructuredBuffer<float> velocityX;
RWStructuredBuffer<float> velocityY;
RWStructuredBuffer<float> velocityZ;


//smoke vorticity
//RWStructuredBuffer<float4> vorticity;


//domain size
int unitPerSide;
float tempAmbiant;
float pressureAtmos;


int3 coordClip(int3 coord, int3 coordMax)
{
    int3 newCoord = int3(0, 0, 0);
    newCoord = max(min(coord, coordMax), newCoord);
    return newCoord;
}

int flatten(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide, unitPerSide, unitPerSide));
    return coord.x + unitPerSide * (coord.y + unitPerSide * coord.z);
}

int flattenPlusOne(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide + 1, unitPerSide + 1, unitPerSide + 1));
    return coord.x + (unitPerSide + 1) * (coord.y + (unitPerSide + 1) * coord.z);
}

bool check(int3 id)
{
    if (id.x < unitPerSide && id.y < unitPerSide && id.z < unitPerSide) return true;
    return false;
}

bool checkPlusOne(int3 id)
{
    if (id.x < (unitPerSide+1) && id.y < (unitPerSide + 1) && id.z < (unitPerSide + 1)) return true;
    return false;
}

[numthreads(4,4,4)]
void CSMain (int3 id : SV_DispatchThreadID)
{

    uint flat = flatten(id);
    uint flatPlusOne = flattenPlusOne(id);

    //init each buffer before the simulation
    
    //check if inbound
    if (check(id))
    {
        smokeDensity[flat] = step(0, 10.0 - distance(float3(id), float3(unitPerSide / 2.0, 0, unitPerSide / 2.0)));
        temperature[flat] = tempAmbiant;
    }

    //another inbound cher
    if (checkPlusOne(id))
    {
        velocityX[flatPlusOne] = 0.0;
        velocityY[flatPlusOne] = 0.0;
        velocityZ[flatPlusOne] = 0.0;

        //vorticity[flatPlusOne] = float4(0.0, 0.0, 0.0, 1.0);
    }

}
