// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.141592653589793
#define TWOPI 6.283185307179586
#define HALFPI 1.570796326794896
#define INV_SQRT_2 0.7071067811865476

//density
RWStructuredBuffer<float> smokeDensity;
RWStructuredBuffer<float> smokeDensityNew;

//temperature
RWStructuredBuffer<float> temperature;
RWStructuredBuffer<float> temperatureNew;

//smoke velocity
RWStructuredBuffer<float> velocityX;
RWStructuredBuffer<float> velocityY;
RWStructuredBuffer<float> velocityZ;

RWStructuredBuffer<float4> velocityNew;

//area of simulation
int unitPerSide;
int unitSize;

//time
float iTime;
float iDeltaTime;

//constants
float tempAmbiant;
float buoyAlpha;
float buoyBeta;

//global value used per shader
int3 coord = int3(0, 0, 0);
int flat;
int flatPlusOne;


//commun
int3 coordClip(int3 p, int3 coordMax)
{
    int3 newCoord = int3(0, 0, 0);
    newCoord = max(min(p, coordMax), newCoord);
    return newCoord;
}

int flatten(int3 p)
{
    p = coordClip(p, int3(unitPerSide, unitPerSide, unitPerSide));
    return p.x + unitPerSide * (p.y + unitPerSide * p.z);
}

int flattenPlusOne(int3 p)
{
    p = coordClip(p, int3(unitPerSide+1, unitPerSide + 1, unitPerSide + 1));
    return p.x + (unitPerSide + 1) * (p.y + (unitPerSide + 1) * p.z);
}

bool check(int3 id)
{
    if (id.x < unitPerSide && id.y < unitPerSide && id.z < unitPerSide) return true;
    return false;
}

bool checkPlusOne(int3 id)
{
    if (id.x < (unitPerSide + 1) && id.y < (unitPerSide + 1) && id.z < (unitPerSide + 1)) return true;
    return false;
}

float interpolate(RWStructuredBuffer<float> b, float3 p, bool plusOne)
{
    //get the starting point of the cube
    float3 p0 = floor(p);

    //get the lerping value
    float3 deltaP = p - p0;
    
    //get the 8 value in a cube
    float x1 = 0.0;
    float x2 = 0.0;
    float x3 = 0.0;
    float x4 = 0.0;
    float x5 = 0.0;
    float x6 = 0.0;
    float x7 = 0.0;
    float x8 = 0.0;

    if (!plusOne)
    {
        x1 = b[flatten(int3(p0.x, p0.y, p0.z))];
        x2 = b[flatten(int3(p0.x + 1, p0.y, p0.z))];
        x3 = b[flatten(int3(p0.x, p0.y + 1, p0.z))];
        x4 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z))];
        x5 = b[flatten(int3(p0.x, p0.y, p0.z + 1))];
        x6 = b[flatten(int3(p0.x + 1, p0.y, p0.z + 1))];
        x7 = b[flatten(int3(p0.x, p0.y + 1, p0.z + 1))];
        x8 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z + 1))];
    }
    else
    {
        x1 = b[flattenPlusOne(int3(p0.x, p0.y, p0.z))];
        x2 = b[flattenPlusOne(int3(p0.x + 1, p0.y, p0.z))];
        x3 = b[flattenPlusOne(int3(p0.x, p0.y + 1, p0.z))];
        x4 = b[flattenPlusOne(int3(p0.x + 1, p0.y + 1, p0.z))];
        x5 = b[flattenPlusOne(int3(p0.x, p0.y, p0.z + 1))];
        x6 = b[flattenPlusOne(int3(p0.x + 1, p0.y, p0.z + 1))];
        x7 = b[flattenPlusOne(int3(p0.x, p0.y + 1, p0.z + 1))];
        x8 = b[flattenPlusOne(int3(p0.x + 1, p0.y + 1, p0.z + 1))];
    }

    //lerp between the x axe
    float x12 = lerp(x1, x2, deltaP.x);
    float x34 = lerp(x3, x4, deltaP.x);
    float x56 = lerp(x5, x6, deltaP.x);
    float x78 = lerp(x5, x6, deltaP.x);

    //lerp between the y axe
    float x1234 = lerp(x12, x34, deltaP.y);
    float x5678 = lerp(x56, x78, deltaP.y);

    //lerp between the z axe
    return lerp(x1234, x5678, deltaP.z);

}
//b is the buffer of the axe currently being use
// 
//axe is the axe being not the axe of averaging 
//(i.e if you're averaging on the X axe then axe should be the Y or Z axe
//
// averageAxe is the axe being averaged
float velocityAerage(RWStructuredBuffer<float> b, int3 axe, int3 averageAxe)
{
    float v = b[flatPlusOne];
    v += b[flattenPlusOne(coord - axe)];
    v += b[flattenPlusOne(coord + averageAxe - axe)];
    v += b[flattenPlusOne(coord + averageAxe)];
    v /= 4;
    return v;
}

float3 advectVelocity()
{
    float3 newVec = float3(0.0, 0.0, 0.0);

    float3 actualCoord = float3(coord);

    if (checkPlusOne(coord))
    {
        //advect vector X part
        float x = velocityX[flatPlusOne];
        float y = velocityAerage(velocityY, int3(0, 1, 0), int3(1, 0, 0));
        float z = velocityAerage(velocityZ, int3(0, 0, 1), int3(1, 0, 0));
        
        //interpolate Z part
        float3 OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.x = interpolate(velocityX, OldCoord, true);

        //advect vector Y part
        x = velocityAerage(velocityX, int3(1, 0, 0), int3(0, 1, 0));
        y = velocityY[flatPlusOne];
        z = velocityAerage(velocityZ, int3(0, 0, 1), int3(0, 1, 0));
        
        //interpolate Y part
        OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.y = interpolate(velocityY, OldCoord, true);

        //advect vector Z part
        x = velocityAerage(velocityX, int3(1, 0, 0), int3(0, 0, 1));
        y = velocityAerage(velocityY, int3(0, 1, 0), int3(0, 0, 1));
        z = velocityZ[flatPlusOne];

        //interpolate Z part
        OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.z = interpolate(velocityZ, OldCoord, true);
    }

    return newVec;
}

float2 advectTempAndDensity()
{
    float newTemp = 0.0;
    float newDensity = 0.0;

    float3 actualCoord = float3(coord);

    if (checkPlusOne(coord))
    {
        float3 newVec = float3(0.0, 0.0, 0.0);

        newVec.x = velocityX[flattenPlusOne(int3(coord.x - 1, coord.y, coord.z))] + velocityX[flatPlusOne]/2;
        newVec.y = velocityY[flattenPlusOne(int3(coord.x, coord.y - 1, coord.z))] + velocityY[flatPlusOne]/2;
        newVec.z = velocityZ[flattenPlusOne(int3(coord.x, coord.y, coord.z - 1))] + velocityZ[flatPlusOne]/2;

        float3 OldCoord = actualCoord - iDeltaTime * newVec;

        newDensity = interpolate(smokeDensity, OldCoord, false);
        newTemp = interpolate(temperature, OldCoord, false);
    }

    return float2(newDensity, newTemp);
}

float3 addExternalForces()
{
	if (check(coord))
	{
		float boyancy = /*-buoyAlpha * pressure[flat] +*/ buoyBeta * (temperature[flat] - tempAmbiant);

        //todo add vorticity confinement


		return iDeltaTime * float3(0.0, boyancy, 0.0);
	}

    return float3(0.0, 0.0, 0.0);
}

float3 updatePressure()
{

}


//float3 project()

[numthreads(4,4,4)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //global coord for the whole shader
    coord = int3(id);
    flat = flatten(coord);
    flatPlusOne = flattenPlusOne(coord);

    //first step
    float3 newVel = advectVelocity();
    newVel += addExternalForces();
    //project();

    //second part
    float2 tempAndDens = advectTempAndDensity();



    if (checkPlusOne(coord))
        velocityNew[flatPlusOne] = float4(newVel, 1.0);

    if (check(coord))
    {
        smokeDensityNew[flat] = tempAndDens.x;
        temperatureNew[flat] = tempAndDens.y;
    }
}
