// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.141592653589793
#define TWOPI 6.283185307179586
#define HALFPI 1.570796326794896
#define INV_SQRT_2 0.7071067811865476

//density
RWStructuredBuffer<float> smokeDensity;
RWStructuredBuffer<float> smokeDensityNew;

//temperature
RWStructuredBuffer<float> temperature;
RWStructuredBuffer<float> temperatureNew;

//smoke velocity
RWStructuredBuffer<float4> velocity;
RWStructuredBuffer<float4> velocityNew;

//intermediate velocity field
RWStructuredBuffer<float4> ccvelocity;

//smoke vorticity
RWStructuredBuffer<float4> vorticity;

//pressure
RWStructuredBuffer<float> pressure;



int unitPerSide;
int unitSize;
float iTime;
float iDeltaTime;

float tempAmbiant;
float buoyAlpha;
float buoyBeta;

int3 coord = int3(0, 0, 0);;

int3 coordClip(int3 coord, int3 coordMax)
{
    int3 newCoord = int3(0, 0, 0);
    newCoord = max(min(coord, coordMax), newCoord);
    return newCoord;
}

int flatten(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide, unitPerSide, unitPerSide));
    return coord.x + unitPerSide * (coord.y + unitPerSide * coord.z);
}

int flattenPlusOne(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide+1, unitPerSide + 1, unitPerSide + 1));
    return coord.x + (unitPerSide + 1) * (coord.y + (unitPerSide + 1) * coord.z);
}

float interpolate(RWStructuredBuffer<float> b, float3 p)
{
    //get the starting point of the cube
    float3 p0 = floor(p);

    //get the lerping value
    float3 deltaP = p0 - p;
    
    //get the 8 value in a cube
    float x1 = b[flatten(int3(p0.x, p0.y, p0.z)];
    float x2 = b[flatten(int3(p0.x + 1, p0.y, p0.z)];
    float x3 = b[flatten(int3(p0.x, p0.y + 1, p0.z)];
    float x4 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z)];
    float x5 = b[flatten(int3(p0.x, p0.y, p0.z + 1)];
    float x6 = b[flatten(int3(p0.x + 1, p0.y, p0.z + 1)];
    float x7 = b[flatten(int3(p0.x, p0.y + 1, p0.z + 1)];
    float x8 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z + 1)];

    //lerp between the x axe
    float x12 = lerp(x1, x2, deltaP.x);
    float x34 = lerp(x3, x4, deltaP.x);
    float x56 = lerp(x5, x6, deltaP.x);
    float x78 = lerp(x5, x6, deltaP.x);

    //lerp between the y axe
    float x1234 = lerp(x12, x34, deltaP.y);
    float x5678 = lerp(x56, x78, deltaP.y);

    //lerp between the z axe
    return lerp(x1234, x5678, deltaP.z);

}

float3 getVelocity(float3 p)
{
	return float3(interpolate(0), interpolate(1) interpolate(2));
}

float3 advectVelocity()
{
	
}

float3 computeExternalForces()
{
	if (coord < int3(unitPerSide, unitPerSide, unitPerSide))
	{
		float boyancy = -buoyAlpha * pressure[flatten(coord)] + buoyBeta(temperature[flatten(Coord)] - tempAmbiant);

		velocityNew[flattenPlusOne(coord)] += iDeltaTime * float3(0.0, boyancy, 0.0);
	}
}

float3 updatePressure()
{

}

float3 worldToSelf(float3 p)
{
	return min(max(0.0, p - unitSize * 0.5), float3(unitPerSide, unitPerSide, unitPerSide));
}


float3 project()

[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //global coord for the whole shader
    coord = int3(id);

    //first step
    advectVelocity();
    addExternalForces();

    //second step
    project();

}
