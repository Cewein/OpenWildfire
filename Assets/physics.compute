// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.141592653589793
#define TWOPI 6.283185307179586
#define HALFPI 1.570796326794896
#define INV_SQRT_2 0.7071067811865476

//density
RWStructuredBuffer<float> smokeDensity;
RWStructuredBuffer<float> smokeDensityNew;

//temperature
RWStructuredBuffer<float> temperature;
RWStructuredBuffer<float> temperatureNew;

//smoke velocity
RWStructuredBuffer<float4> velocity;
RWStructuredBuffer<float4> velocityNew;

//intermediate velocity field
RWStructuredBuffer<float4> ccvelocity;

//smoke vorticity
RWStructuredBuffer<float4> vorticity;

//pressure
RWStructuredBuffer<float> pressure;



int unitPerSide;
int unitSize;
float iTime;
float iDeltaTime;

float tempAmbiant;
float buoyAlpha;
float buoyBeta;

int3 coord = int3(0, 0, 0);;

int3 coordClip(int3 coord, int3 coordMax)
{
    int3 newCoord = int3(0, 0, 0);
    newCoord = max(min(coord, coordMax), newCoord);
    return newCoord;
}

int flatten(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide, unitPerSide, unitPerSide));
    return coord.x + unitPerSide * (coord.y + unitPerSide * coord.z);
}

int flattenPlusOne(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide+1, unitPerSide + 1, unitPerSide + 1));
    return coord.x + (unitPerSide + 1) * (coord.y + (unitPerSide + 1) * coord.z);
}


float3 advectVelocity()
{

}

float3 computeExternalForces()
{
    float boyancy = -buoyAlpha * pressure[flatten(coord)] + buoyBeta(temperature[flatten(Coord)] - tempAmbiant);

    return float3(0.0, boyancy, 0.0);
}

float3 updatePressure()
{

}

float3 project()

[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    coord = int3(id);
    advectVelocity()

}
