// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.141592653589793
#define TWOPI 6.283185307179586
#define HALFPI 1.570796326794896
#define INV_SQRT_2 0.7071067811865476

//pressure
RWStructuredBuffer<float> smokeDensity;
RWStructuredBuffer<float> smokeDensityNew;

//temperature
RWStructuredBuffer<float> temperature;
RWStructuredBuffer<float> temperatureNew;

//smoke velocity
RWStructuredBuffer<float4> velocity;
RWStructuredBuffer<float4> velocityNew;

//intermediate velocity field
RWStructuredBuffer<float4> ccvelocity;

//smoke vorticity
RWStructuredBuffer<float4> vorticity;

//display property of smoke (radiance mean brigthness)
RWStructuredBuffer<float> smokeVoxelRadiance;
RWStructuredBuffer<float> smokeVoxelTransparency;

int unitPerSide;
int unitSize;
float iTime;

float tempAmbiant;
float buoyAlpha;
float buoyBeta;

int3 coordClip(int3 coord, int3 coordMax)
{
    int3 newCoord;
    newCoord.x = coord.x > (coordMax.x - 1) ? (coordMax.x - 1) : (coord.x < 0 ? 0 : coord.x);
    newCoord.x = coord.y > (coordMax.y - 1) ? (coordMax.y - 1) : (coord.y < 0 ? 0 : coord.y);
    newCoord.x = coord.z > (coordMax.z - 1) ? (coordMax.z - 1) : (coord.z < 0 ? 0 : coord.z);

    return newCoord;
}

int flatten(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide, unitPerSide, unitPerSide));
    return coord.x + unitPerSide * (coord.y + unitPerSide * coord.z);
}


void computeTemperature(int3 coord)
{
    temperatureNew[flatten(coord)] = -advection(coord,unitSize) * temperature[flatten(coord)]
}

void computePressure(int3 coord)
{
    smokeDensityNew[flatten(coord)] = -advection(coord, unitSize) * smokeDensity[flatten(coord)]
}


float4 advection(int3 u, float h)
{
    uint3 u;
    uint3 v;
    uint3 w;
}

void computeVorticity()
{

}

//compute the Buoyancy from the pressure and temperature
float3 computeBuoyancy(int3 u)
{
    float pressure = smokeDensity[flatten(u)];
    float temp = temperature[flatten(u)];
    float3 z = float3(0.0, 0.0, 1.0);

    return -buoyAlpha * pressure * z + buoyBeta * (temp - tempAmbiant) * z;
}

void computeIntermediateVelocityField(int3 u)
{
    return -advection(u, unitSize) * velocity[flattenPlusOne(int3(u.x, u.y, u.z))];
}

void changeOldToNew(int3 coord)
{
    smokeDensity[flatten(Coord)] = smokeDensityNew[flatten(coord)];
    temperature[flatten(Coord)] = temperatureNew[flatten(coord)];
    velocity[flatten(Coord)] = velocityNew[flatten(coord)];
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //smokeDensity[flatten(id)] = 

    changeOldToNew(int3(id));
}
