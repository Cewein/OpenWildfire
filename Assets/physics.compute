// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.141592653589793
#define TWOPI 6.283185307179586
#define HALFPI 1.570796326794896
#define INV_SQRT_2 0.7071067811865476

//density
RWStructuredBuffer<float> smokeDensity;
RWStructuredBuffer<float> smokeDensityNew;

//temperature
RWStructuredBuffer<float> temperature;
RWStructuredBuffer<float> temperatureNew;

//smoke velocity
RWStructuredBuffer<float> velocityX;
RWStructuredBuffer<float> velocityY;
RWStructuredBuffer<float> velocityZ;

RWStructuredBuffer<float> velocityNewX;
RWStructuredBuffer<float> velocityNewY;
RWStructuredBuffer<float> velocityNewZ;

//intermediate velocity field
RWStructuredBuffer<float4> ccvelocity;

//smoke vorticity
RWStructuredBuffer<float4> vorticity;

//pressure
RWStructuredBuffer<float> pressure;

//area of simulation
int unitPerSide;
int unitSize;

//time
float iTime;
float iDeltaTime;

//constants
float tempAmbiant;
float buoyAlpha;
float buoyBeta;

//global value used per shader
int3 coord = int3(0, 0, 0);
int flat;
int flatPlusOne;

int3 coordClip(int3 coord, int3 coordMax)
{
    int3 newCoord = int3(0, 0, 0);
    newCoord = max(min(coord, coordMax), newCoord);
    return newCoord;
}

int flatten(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide, unitPerSide, unitPerSide));
    return coord.x + unitPerSide * (coord.y + unitPerSide * coord.z);
}

int flattenPlusOne(int3 coord)
{
    coord = coordClip(coord, int3(unitPerSide+1, unitPerSide + 1, unitPerSide + 1));
    return coord.x + (unitPerSide + 1) * (coord.y + (unitPerSide + 1) * coord.z);
}

float interpolate(RWStructuredBuffer<float> b, float3 p, bool plusOne)
{
    //get the starting point of the cube
    float3 p0 = floor(p);

    //get the lerping value
    float3 deltaP = p0 - p;
    
    //get the 8 value in a cube
    float x1 = 0.0;
    float x2 = 0.0;
    float x3 = 0.0;
    float x4 = 0.0;
    float x5 = 0.0;
    float x6 = 0.0;
    float x7 = 0.0;
    float x8 = 0.0;

    if (!plusOne)
    {
        x1 = b[flatten(int3(p0.x, p0.y, p0.z))];
        x2 = b[flatten(int3(p0.x + 1, p0.y, p0.z))];
        x3 = b[flatten(int3(p0.x, p0.y + 1, p0.z))];
        x4 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z))];
        x5 = b[flatten(int3(p0.x, p0.y, p0.z + 1))];
        x6 = b[flatten(int3(p0.x + 1, p0.y, p0.z + 1))];
        x7 = b[flatten(int3(p0.x, p0.y + 1, p0.z + 1))];
        x8 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z + 1))];
    }
    else
    {
        x1 = b[flattenPlusOne(int3(p0.x, p0.y, p0.z))];
        x2 = b[flattenPlusOne(int3(p0.x + 1, p0.y, p0.z))];
        x3 = b[flattenPlusOne(int3(p0.x, p0.y + 1, p0.z))];
        x4 = b[flattenPlusOne(int3(p0.x + 1, p0.y + 1, p0.z))];
        x5 = b[flattenPlusOne(int3(p0.x, p0.y, p0.z + 1))];
        x6 = b[flattenPlusOne(int3(p0.x + 1, p0.y, p0.z + 1))];
        x7 = b[flattenPlusOne(int3(p0.x, p0.y + 1, p0.z + 1))];
        x8 = b[flattenPlusOne(int3(p0.x + 1, p0.y + 1, p0.z + 1))];
    }

    //lerp between the x axe
    float x12 = lerp(x1, x2, deltaP.x);
    float x34 = lerp(x3, x4, deltaP.x);
    float x56 = lerp(x5, x6, deltaP.x);
    float x78 = lerp(x5, x6, deltaP.x);

    //lerp between the y axe
    float x1234 = lerp(x12, x34, deltaP.y);
    float x5678 = lerp(x56, x78, deltaP.y);

    //lerp between the z axe
    return lerp(x1234, x5678, deltaP.z);

}
//b is the buffer of the axe currently being use
// 
//axe is the axe being not the axe of averaging 
//(i.e if you're averaging on the X axe then axe should be the Y or Z axe
//
// averageAxe is the axe being averaged
float velocityAerage(RWStructuredBuffer<float> b, int3 axe, int3 averageAxe)
{
    float v = b[flatPlusOne];
    v += b[flattenPlusOne(coord - axe)];
    v += b[flattenPlusOne(coord + averageAxe - axe)];
    v += b[flattenPlusOne(coord + averageAxe)];
    v /= 4;
    return v;
}

float3 advectVelocity()
{
    float3 newVec = float3(0.0, 0.0, 0.0);

    float3 actualCoord = float3(coord);

    if (flatPlusOne < pow((unitPerSide + 1),3))
    {
        //advect vector X part
        float x = velocityX[flatPlusOne];
        float y = velocityAerage(velocityY, int3(0, 1, 0), int3(1, 0, 0));
        float z = velocityAerage(velocityZ, int3(0, 0, 1), int3(1, 0, 0));
        
        //interpolate Z part
        float3 OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.x = interpolate(velocityX, OldCoord, true);

        //advect vector Y part
        x = velocityAerage(velocityX, int3(1, 0, 0), int3(0, 1, 0));
        y = velocityY[flatPlusOne];
        z = velocityAerage(velocityZ, int3(0, 0, 1), int3(0, 1, 0));
        
        //interpolate Y part
        OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.y = interpolate(velocityX, OldCoord, true);

        //advect vector Z part
        x = velocityAerage(velocityX, int3(1, 0, 0), int3(0, 0, 1));
        y = velocityAerage(velocityY, int3(0, 1, 0), int3(0, 0, 1));
        z = velocityZ[flatPlusOne];

        //interpolate Z part
        OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.z = interpolate(velocityX, OldCoord, true);
    }

    return newVec;
}

float2 advectTempAndDensity()
{
    float newTemp = 0.0;
    float newDensity = 0.0;

    float3 actualCoord = float3(coord);

    if (flatPlusOne < pow((unitPerSide + 1), 3))
    {
        float3 newVec = float3(0.0, 0.0, 0.0);

        newVec.x = velocityX[flattenPlusOne(int3(coord.x - 1, coord.y, coord.z))] + velocityX[flatPlusOne]/2;
        newVec.y = velocityY[flattenPlusOne(int3(coord.x, coord.y - 1, coord.z))] + velocityX[flatPlusOne]/2;
        newVec.z = velocityZ[flattenPlusOne(int3(coord.x, coord.y, coord.z - 1))] + velocityX[flatPlusOne]/2;

        float3 OldCoord = actualCoord - iDeltaTime * newVec;

        newDensity = interpolate(smokeDensity, OldCoord, false);
        newTemp = interpolate(temperature, OldCoord, false);
    }

    return float2(newDensity, newTemp);
}

float3 addExternalForces()
{
	if (flat < pow(unitPerSide, 3))
	{
		float boyancy = -buoyAlpha * pressure[flat] + buoyBeta*(temperature[flat] - tempAmbiant);

        //todo add vorticity confinement


		return iDeltaTime * float3(0.0, boyancy, 0.0);
	}

    return float3(0.0, 0.0, 0.0);
}

float3 updatePressure()
{

}

float3 worldToSelf(float3 p)
{
	return min(max(0.0, p - unitSize * 0.5), float3(unitPerSide, unitPerSide, unitPerSide));
}


//float3 project()

[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //global coord for the whole shader
    coord = int3(id);
    flat = flatten(id);
    flatPlusOne = flattenPlusOne(id);

    //first step
    float3 newVel = advectVelocity();
    newVel += addExternalForces();
    //project();

    //second part
    float2 tempAndDens = advectTempAndDensity();

    velocityX[flatPlusOne] = newVel.x;
    velocityY[flatPlusOne] = newVel.y;
    velocityZ[flatPlusOne] = newVel.z;

    temperature[flat] = tempAndDens.x;
    smokeDensity[flat] = tempAndDens.y;
}
