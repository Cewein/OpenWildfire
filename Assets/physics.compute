// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.141592653589793
#define TWOPI 6.283185307179586
#define HALFPI 1.570796326794896
#define INV_SQRT_2 0.7071067811865476

//temperature and density
//x and y are temperature and density
//z and w are new temperature and new density
RWStructuredBuffer<float4> TempAndDensity;

//smoke velocity
RWStructuredBuffer<float4> velocity;

RWStructuredBuffer<float4> velocityNew;

//area of simulation
int unitPerSide;
int unitSize;

//time
float iTime;
float iDeltaTime;

//constants
float tempAmbiant;
float buoyAlpha;
float buoyBeta;

//global value used per shader
int3 coord = int3(0, 0, 0);
int flat;
int flatPlusOne;


// coord test and flatten function //
int3 coordClip(int3 p, int3 coordMax)
{
    int3 newCoord = int3(0, 0, 0);
    newCoord = max(min(p, coordMax), newCoord);
    return newCoord;
}

int flatten(int3 p)
{
    p = coordClip(p, int3(unitPerSide, unitPerSide, unitPerSide));
    return p.x + unitPerSide * (p.y + unitPerSide * p.z);
}

int flattenPlusOne(int3 p)
{
    p = coordClip(p, int3(unitPerSide+1, unitPerSide + 1, unitPerSide + 1));
    return p.x + (unitPerSide + 1) * (p.y + (unitPerSide + 1) * p.z);
}

bool check(int3 id)
{
    if (id.x < unitPerSide && id.y < unitPerSide && id.z < unitPerSide) return true;
    return false;
}

bool checkPlusOne(int3 id)
{
    if (id.x < (unitPerSide + 1) && id.y < (unitPerSide + 1) && id.z < (unitPerSide + 1)) return true;
    return false;
}

//trilinear interpolation based on float 4 structure but only use 1 dimention.
//b is the float 4 bufer
//p is the point where you want to sample and interpolate
//axe is the dimension you want to interpolate
//plusOne is to use the array length or the array length + 1
float interpolate(RWStructuredBuffer<float4> b, float3 p, int axe,bool plusOne)
{
    //get the starting point of the cube
    float3 p0 = floor(p);

    //get the lerping value
    float3 deltaP = p - p0;
    
    //get the 8 value in a cube
    float x1 = 0.0;
    float x2 = 0.0;
    float x3 = 0.0;
    float x4 = 0.0;
    float x5 = 0.0;
    float x6 = 0.0;
    float x7 = 0.0;
    float x8 = 0.0;

    if (!plusOne)
    {
        x1 = b[flatten(int3(p0.x, p0.y, p0.z))][axe];
        x2 = b[flatten(int3(p0.x + 1, p0.y, p0.z))][axe];
        x3 = b[flatten(int3(p0.x, p0.y + 1, p0.z))][axe];
        x4 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z))][axe];
        x5 = b[flatten(int3(p0.x, p0.y, p0.z + 1))][axe];
        x6 = b[flatten(int3(p0.x + 1, p0.y, p0.z + 1))][axe];
        x7 = b[flatten(int3(p0.x, p0.y + 1, p0.z + 1))][axe];
        x8 = b[flatten(int3(p0.x + 1, p0.y + 1, p0.z + 1))][axe];
    }
    else
    {
        x1 = b[flattenPlusOne(int3(p0.x, p0.y, p0.z))][axe];
        x2 = b[flattenPlusOne(int3(p0.x + 1, p0.y, p0.z))][axe];
        x3 = b[flattenPlusOne(int3(p0.x, p0.y + 1, p0.z))][axe];
        x4 = b[flattenPlusOne(int3(p0.x + 1, p0.y + 1, p0.z))][axe];
        x5 = b[flattenPlusOne(int3(p0.x, p0.y, p0.z + 1))][axe];
        x6 = b[flattenPlusOne(int3(p0.x + 1, p0.y, p0.z + 1))][axe];
        x7 = b[flattenPlusOne(int3(p0.x, p0.y + 1, p0.z + 1))][axe];
        x8 = b[flattenPlusOne(int3(p0.x + 1, p0.y + 1, p0.z + 1))][axe];
    }

    //lerp between the x axe
    float x12 = lerp(x1, x2, deltaP.x);
    float x34 = lerp(x3, x4, deltaP.x);
    float x56 = lerp(x5, x6, deltaP.x);
    float x78 = lerp(x5, x6, deltaP.x);

    //lerp between the y axe
    float x1234 = lerp(x12, x34, deltaP.y);
    float x5678 = lerp(x56, x78, deltaP.y);

    //lerp between the z axe
    return lerp(x1234, x5678, deltaP.z);

}
//b is the buffer of the axe currently being use
// 
//axe is the axe being not the axe of averaging 
//(i.e if you're averaging on the X axe then axe should be the Y or Z axe
//
// averageAxe is the axe being averaged
// dim is the dimension use in the averaging
// we have to do that since the MAC grid is fully integrated into a float4 array buffer
float velocityAerage(RWStructuredBuffer<float4> b, int3 axe, int3 averageAxe,int dim)
{
    float v = b[flatPlusOne][dim];
    v += b[flattenPlusOne(coord - axe)][dim];
    v += b[flattenPlusOne(coord + averageAxe - axe)][dim];
    v += b[flattenPlusOne(coord + averageAxe)][dim];
    v /= 4;
    return v;
}

float3 advectVelocity()
{
    float3 newVec = float3(0.0, 0.0, 0.0);

    float3 actualCoord = float3(coord);

    if (checkPlusOne(coord))
    {
        //advect vector X part
        float x = velocity[flatPlusOne].x;
        float y = velocityAerage(velocity, int3(0, 1, 0), int3(1, 0, 0),1);
        float z = velocityAerage(velocity, int3(0, 0, 1), int3(1, 0, 0),2);
        
        //interpolate Z part
        float3 OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.x = interpolate(velocity, OldCoord,0, true);

        //advect vector Y part
        x = velocityAerage(velocity, int3(1, 0, 0), int3(0, 1, 0),0);
        y = velocity[flatPlusOne].y;
        z = velocityAerage(velocity, int3(0, 0, 1), int3(0, 1, 0),2);
        
        //interpolate Y part
        OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.y = interpolate(velocity, OldCoord,1, true);

        //advect vector Z part
        x = velocityAerage(velocity, int3(1, 0, 0), int3(0, 0, 1),0);
        y = velocityAerage(velocity, int3(0, 1, 0), int3(0, 0, 1),1);
        z = velocity[flatPlusOne].z;

        //interpolate Z part
        OldCoord = actualCoord - iDeltaTime * float3(x, y, z);
        newVec.z = interpolate(velocity, OldCoord,2, true);
    }

    return newVec;
}

float2 advectTempAndDensity()
{
    float newTemp = 0.0;
    float newDensity = 0.0;

    float3 actualCoord = float3(coord);

    if (checkPlusOne(coord))
    {
        float3 newVec = float3(0.0, 0.0, 0.0);

        newVec.x = velocity[flattenPlusOne(int3(coord.x - 1, coord.y, coord.z))].x + velocity[flattenPlusOne(int3(coord.x + 1, coord.y, coord.z))].x / 2;
        newVec.y = velocity[flattenPlusOne(int3(coord.x, coord.y - 1, coord.z))].y + velocity[flattenPlusOne(int3(coord.x, coord.y + 1, coord.z))].y / 2;
        newVec.z = velocity[flattenPlusOne(int3(coord.x, coord.y, coord.z - 1))].z + velocity[flattenPlusOne(int3(coord.x, coord.y, coord.z + 1))].z /2;

        float3 OldCoord = actualCoord - iDeltaTime * newVec;

        newTemp = interpolate(TempAndDensity, OldCoord, 0, false);
        newDensity = interpolate(TempAndDensity, OldCoord, 1, false);
    }

    return float2(newTemp, newDensity);
}

float3 addExternalForces()
{
	if (check(coord))
	{
		float boyancy = /*-buoyAlpha * pressure[flat] +*/ buoyBeta * (TempAndDensity[flat].x - tempAmbiant);

        //todo add vorticity confinement


		return iDeltaTime * float3(0.0, boyancy, 0.0);
	}

    return float3(0.0, 0.0, 0.0);
}

float3 updatePressure()
{

}


//float3 project()

[numthreads(4,4,4)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //global coord for the whole shader
    coord = int3(id);
    flat = flatten(coord);
    flatPlusOne = flattenPlusOne(coord);

    //first step
    float3 newVel = advectVelocity();
    newVel += addExternalForces();
    //project();

    //second part
    float2 tempAndDens = advectTempAndDensity();



    if (checkPlusOne(coord))
        velocityNew[flatPlusOne] = float4(newVel, 1.0);

    if (check(coord))
    {
        TempAndDensity[flat].z = tempAndDens.x; //temp
        TempAndDensity[flat].w = tempAndDens.y; //density
    }
}
